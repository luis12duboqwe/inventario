import {
  downloadInventoryCsv,
  downloadInventoryCurrentCsv,
  downloadInventoryCurrentPdf,
  downloadInventoryCurrentXlsx,
  downloadInventoryMovementsCsv,
  downloadInventoryMovementsPdf,
  downloadInventoryMovementsXlsx,
  downloadInventoryAdjustmentsCsv,
  downloadInventoryAdjustmentsPdf,
  downloadInventoryAuditCsv,
  downloadInventoryAuditPdf,
  downloadInventoryPdf,
  downloadInventoryValueCsv,
  downloadInventoryValuePdf,
  downloadInventoryValueXlsx,
  downloadTopProductsCsv,
  downloadTopProductsPdf,
  downloadTopProductsXlsx,
  exportStoreDevicesCsv,
  getDevices,
  listWarehouses,
  createWarehouse,
  transferBetweenWarehouses,
  getIncompleteDevices,
  getInventoryReservations,
  getInventoryCurrentReport,
  getInventoryMovementsReport,
  getInventoryValueReport,
  getTopProductsReport,
  getInactiveProductsReport,
  getSyncDiscrepancyReport,
  getProductVariants,
  getProductBundles,
  createProductVariant,
  updateProductVariant,
  archiveProductVariant,
  createProductBundle,
  updateProductBundle,
  archiveProductBundle,
  importStoreDevicesCsv,
  createInventoryReservation,
  renewInventoryReservation,
  cancelInventoryReservation,
  registerMovement,
  registerInventoryReceiving,
  registerInventoryCycleCount,
  smartInventoryImport,
  getSmartImportHistory,
  updateDevice,
} from "@api/inventory";
import { getSupplierBatchOverview, SupplierBatchOverviewItem } from "@api/suppliers";
import type {
  InventoryCurrentFilters,
  InventoryImportHistoryEntry,
  InventoryCurrentReport,
  InventoryMovementsFilters,
  InventoryMovementsReport,
  InventorySmartImportResponse,
  InventoryTopProductsFilters,
  InventoryValueFilters,
  InventoryValueReport,
  InactiveProductsFilters,
  InactiveProductsReport,
  SyncDiscrepancyFilters,
  SyncDiscrepancyReport,
  InventoryReservation,
  InventoryReservationInput,
  InventoryReservationRenewInput,
  MovementInput,
  PaginatedResponse,
  ProductVariant,
  ProductVariantCreateInput,
  ProductVariantUpdateInput,
  ProductBundle,
  ProductBundleCreateInput,
  ProductBundleUpdateInput,
  TopProductsReport,
  InventoryReceivingRequest,
  InventoryReceivingResult,
  InventoryCycleCountRequest,
  InventoryCycleCountResult,
  InventoryAuditFilters,
  Warehouse,
  WarehouseTransferInput,
  DeviceUpdateInput,
  Device,
} from "@api/inventory";

export const inventoryService = {
  fetchDevices: getDevices,
  updateDevice: (
    token: string,
    storeId: number,
    deviceId: number,
    payload: DeviceUpdateInput,
    reason: string,
  ): Promise<Device> => updateDevice(token, storeId, deviceId, payload, reason),
  fetchWarehouses: (token: string, storeId: number): Promise<Warehouse[]> =>
    listWarehouses(token, storeId),
  createWarehouse: (
    token: string,
    storeId: number,
    payload: Pick<Warehouse, "name" | "code" | "is_default">,
    reason: string,
  ): Promise<Warehouse> => createWarehouse(token, storeId, payload, reason),
  transferBetweenWarehouses: (
    token: string,
    payload: WarehouseTransferInput,
    reason: string,
  ) => transferBetweenWarehouses(token, payload, reason),
  fetchVariants: (
    token: string,
    params: Parameters<typeof getProductVariants>[1] = {},
  ): Promise<ProductVariant[]> => getProductVariants(token, params),
  createVariant: (
    token: string,
    deviceId: number,
    payload: ProductVariantCreateInput,
    reason: string,
  ): Promise<ProductVariant> => createProductVariant(token, deviceId, payload, reason),
  updateVariant: (
    token: string,
    variantId: number,
    payload: ProductVariantUpdateInput,
    reason: string,
  ): Promise<ProductVariant> => updateProductVariant(token, variantId, payload, reason),
  archiveVariant: (
    token: string,
    variantId: number,
    reason: string,
  ): Promise<ProductVariant> => archiveProductVariant(token, variantId, reason),
  fetchBundles: (
    token: string,
    params: Parameters<typeof getProductBundles>[1] = {},
  ): Promise<ProductBundle[]> => getProductBundles(token, params),
  createBundle: (
    token: string,
    payload: ProductBundleCreateInput,
    reason: string,
  ): Promise<ProductBundle> => createProductBundle(token, payload, reason),
  updateBundle: (
    token: string,
    bundleId: number,
    payload: ProductBundleUpdateInput,
    reason: string,
  ): Promise<ProductBundle> => updateProductBundle(token, bundleId, payload, reason),
  archiveBundle: (
    token: string,
    bundleId: number,
    reason: string,
  ): Promise<ProductBundle> => archiveProductBundle(token, bundleId, reason),
  registerMovement: (
    token: string,
    storeId: number,
    payload: MovementInput,
    comment: string,
  ) => registerMovement(token, storeId, payload, comment),
  registerReceiving: (
    token: string,
    payload: InventoryReceivingRequest,
    reason: string,
  ): Promise<InventoryReceivingResult> => registerInventoryReceiving(token, payload, reason),
  registerCycleCount: (
    token: string,
    payload: InventoryCycleCountRequest,
    reason: string,
  ): Promise<InventoryCycleCountResult> => registerInventoryCycleCount(token, payload, reason),
  downloadInventoryReport: (token: string, reason: string) =>
    downloadInventoryPdf(token, reason),
  downloadInventoryCsv: (token: string, reason: string) =>
    downloadInventoryCsv(token, reason),
  exportCatalogCsv: (
    token: string,
    storeId: number,
    filters: Parameters<typeof getDevices>[2] = {},
    reason: string,
  ) => exportStoreDevicesCsv(token, storeId, filters, reason),
  importCatalogCsv: (
    token: string,
    storeId: number,
    file: File,
    reason: string,
  ): Promise<InventorySmartImportResponse> => importStoreDevicesCsv(token, storeId, file, reason),
  smartImportInventory: (
    token: string,
    file: File,
    reason: string,
    options: Parameters<typeof smartInventoryImport>[3] = {},
  ): Promise<InventorySmartImportResponse> =>
    smartInventoryImport(token, file, reason, options),
  fetchSmartImportHistory: (
    token: string,
    limit = 10,
  ): Promise<InventoryImportHistoryEntry[]> => getSmartImportHistory(token, limit),
  fetchIncompleteDevices: (
    token: string,
    storeId?: number,
    limit = 100,
  ) => getIncompleteDevices(token, storeId, limit),
  fetchReservations: (
    token: string,
    params: Parameters<typeof getInventoryReservations>[1],
  ): Promise<PaginatedResponse<InventoryReservation>> =>
    getInventoryReservations(token, params),
  createReservation: (
    token: string,
    payload: InventoryReservationInput,
    reason: string,
  ): Promise<InventoryReservation> =>
    createInventoryReservation(token, payload, reason),
  renewReservation: (
    token: string,
    reservationId: number,
    payload: InventoryReservationRenewInput,
    reason: string,
  ): Promise<InventoryReservation> =>
    renewInventoryReservation(token, reservationId, payload, reason),
  cancelReservation: (
    token: string,
    reservationId: number,
    reason: string,
  ): Promise<InventoryReservation> =>
    cancelInventoryReservation(token, reservationId, reason),
  fetchSupplierBatchOverview: (
    token: string,
    storeId: number,
    limit = 5,
  ): Promise<SupplierBatchOverviewItem[]> =>
    getSupplierBatchOverview(token, storeId, limit),
  fetchInventoryCurrentReport: (
    token: string,
    filters: InventoryCurrentFilters = {},
  ): Promise<InventoryCurrentReport> => getInventoryCurrentReport(token, filters),
  fetchInventoryValueReport: (
    token: string,
    filters: InventoryValueFilters = {},
  ): Promise<InventoryValueReport> => getInventoryValueReport(token, filters),
  fetchInactiveProductsReport: (
    token: string,
    filters: InactiveProductsFilters = {},
  ): Promise<InactiveProductsReport> => getInactiveProductsReport(token, filters),
  fetchInventoryMovementsReport: (
    token: string,
    filters: InventoryMovementsFilters = {},
  ): Promise<InventoryMovementsReport> => getInventoryMovementsReport(token, filters),
  fetchTopProductsReport: (
    token: string,
    filters: InventoryTopProductsFilters = {},
  ): Promise<TopProductsReport> => getTopProductsReport(token, filters),
  fetchSyncDiscrepancyReport: (
    token: string,
    filters: SyncDiscrepancyFilters = {},
  ): Promise<SyncDiscrepancyReport> => getSyncDiscrepancyReport(token, filters),
  downloadInventoryCurrentCsv: (
    token: string,
    reason: string,
    filters: InventoryCurrentFilters = {},
  ) => downloadInventoryCurrentCsv(token, filters, reason),
  downloadInventoryCurrentPdf: (
    token: string,
    reason: string,
    filters: InventoryCurrentFilters = {},
  ) => downloadInventoryCurrentPdf(token, filters, reason),
  downloadInventoryCurrentXlsx: (
    token: string,
    reason: string,
    filters: InventoryCurrentFilters = {},
  ) => downloadInventoryCurrentXlsx(token, filters, reason),
  downloadInventoryValueCsv: (
    token: string,
    reason: string,
    filters: InventoryValueFilters = {},
  ) => downloadInventoryValueCsv(token, filters, reason),
  downloadInventoryValuePdf: (
    token: string,
    reason: string,
    filters: InventoryValueFilters = {},
  ) => downloadInventoryValuePdf(token, reason, filters),
  downloadInventoryValueXlsx: (
    token: string,
    reason: string,
    filters: InventoryValueFilters = {},
  ) => downloadInventoryValueXlsx(token, reason, filters),
  downloadInventoryMovementsCsv: (
    token: string,
    reason: string,
    filters: InventoryMovementsFilters = {},
  ) => downloadInventoryMovementsCsv(token, reason, filters),
  downloadInventoryMovementsPdf: (
    token: string,
    reason: string,
    filters: InventoryMovementsFilters = {},
  ) => downloadInventoryMovementsPdf(token, reason, filters),
  downloadInventoryMovementsXlsx: (
    token: string,
    reason: string,
    filters: InventoryMovementsFilters = {},
  ) => downloadInventoryMovementsXlsx(token, reason, filters),
  downloadInventoryAdjustmentsCsv: (
    token: string,
    reason: string,
    filters: InventoryMovementsFilters = {},
  ) => downloadInventoryAdjustmentsCsv(token, reason, filters),
  downloadInventoryAdjustmentsPdf: (
    token: string,
    reason: string,
    filters: InventoryMovementsFilters = {},
  ) => downloadInventoryAdjustmentsPdf(token, reason, filters),
  downloadInventoryAuditCsv: (
    token: string,
    reason: string,
    filters: InventoryAuditFilters = {},
  ) => downloadInventoryAuditCsv(token, reason, filters),
  downloadInventoryAuditPdf: (
    token: string,
    reason: string,
    filters: InventoryAuditFilters = {},
  ) => downloadInventoryAuditPdf(token, reason, filters),
  downloadTopProductsCsv: (
    token: string,
    reason: string,
    filters: InventoryTopProductsFilters = {},
  ) => downloadTopProductsCsv(token, reason, filters),
  downloadTopProductsPdf: (
    token: string,
    reason: string,
    filters: InventoryTopProductsFilters = {},
  ) => downloadTopProductsPdf(token, reason, filters),
  downloadTopProductsXlsx: (
    token: string,
    reason: string,
    filters: InventoryTopProductsFilters = {},
  ) => downloadTopProductsXlsx(token, reason, filters),
};
